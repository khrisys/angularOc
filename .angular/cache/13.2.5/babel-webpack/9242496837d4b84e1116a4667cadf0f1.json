{
  "ast": null,
  "code": "import { Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\n/**\r\n * Attention à bien rajouter @Injectable() pour que les appels rest fonctionnent vers firebase\r\n */\n\nexport let UserService = /*#__PURE__*/(() => {\n  class UserService {\n    constructor(httpClient) {\n      this.httpClient = httpClient;\n      this.userSubject = new Subject(); // Equivalent de la reception d'un tableau d'objet via une API, sous format json\n      // Array utilisé avec *ngFor\n      // Mettre l'array 'private' permet d'empecher la amnipulation et l'acces depuis l'exteiruer de l'appli aux données. Sert pour la couche\n      // d'abstraction 'Subject'. Cet array est uniquement accessible depuis l'interieur du service\n\n      this.users = [{\n        id: 1,\n        name: 'kiki',\n        status: 'retraité'\n      }, {\n        id: 2,\n        name: 'toto',\n        status: 'retraité'\n      }, {\n        id: 3,\n        name: 'tata',\n        status: 'actif'\n      }];\n    }\n    /**\r\n     * Retourne l'objet User par son id, id qui est passé en argument dans l'url\r\n     *\r\n     * @param id\r\n     */\n\n\n    getUserById(id) {\n      const utilisateur = this.users.find(userObject => {\n        return userObject.id === id;\n      });\n      return utilisateur;\n    }\n    /**\r\n     * Permet que le Subject emette la liste des users. C'est la couche d'abstraction pour l'utilisation des données recues depuis un\r\n     * fichier json, d'une API, etc. Ca va permettre d'acceder aux données depuis l'exterieur. C'est le concept du \"Ouvert à\r\n     * l'extension/fermé à la modif\"\r\n     *\r\n     * la methode 'next()' force le subject à emettre ce qu'on lui passe comme argument\r\n     * la methode 'slice()' permet de faire une copie du tableau d'objet 'users' privé\r\n     */\n\n\n    emitUserSubject() {\n      this.userSubject.next(this.users.slice());\n    } // ===============================================================\n    // Methodes métier\n    // ==============================================================\n\n    /**\r\n     * Defini tous les users à la retraite\r\n     * Avec la couche d'abstraction entre données recues et traitement dans l'appli, on fait emettre le Subject. Ainsi, les components qui\r\n     * se sont souscris à ce subject verront le changement automatiquement.\r\n     */\n\n\n    retireAll() {\n      for (let user of this.users) {\n        user.status = 'retraité';\n      }\n\n      this.emitUserSubject();\n    }\n    /**\r\n     * Rend tous les users comme actifs\r\n     * Avec la couche d'abstraction entre données recues et traitement dans l'appli, on fait emettre le Subject. Ainsi, les components qui\r\n     * se sont souscris à ce subject verront le changement automatiquement.\r\n     */\n\n\n    activeAll() {\n      for (let user of this.users) {\n        user.status = 'actif';\n      }\n\n      this.emitUserSubject();\n    }\n    /**\r\n     * Défini un seul user à la retraite\r\n     * Avec la couche d'abstraction entre données recues et traitement dans l'appli, on fait emettre le Subject. Ainsi, les components qui\r\n     * se sont souscris à ce subject verront le changement automatiquement.\r\n     */\n\n\n    retireOne(index) {\n      this.users[index].status = 'retraité';\n      this.emitUserSubject();\n    }\n    /**\r\n     * Défini un user précis comme actif\r\n     * Avec la couche d'abstraction entre données recues et traitement dans l'appli, on fait emettre le Subject. Ainsi, les components qui\r\n     * se sont souscris à ce subject verront le changement automatiquement.\r\n     *\r\n     * @param index : index de l'user dans la liste json d'objets User\r\n     */\n\n\n    activeOne(index) {\n      this.users[index].status = 'actif';\n      this.emitUserSubject();\n    }\n    /**\r\n     * Methode d'edition permettant d'ajouter un user à la liste des users\r\n     *\r\n     * @param name\r\n     * @param status\r\n     */\n\n\n    addUser(name, status) {\n      const userObject = {\n        id: 0,\n        name: '',\n        status: ''\n      }; // On recupere l'id du dernier element de la liste (avec le length -1) ausuel on rajoute 1 pour incrementer l'id\n\n      userObject.id = this.users[this.users.length - 1].id + 1;\n      userObject.name = name;\n      userObject.status = status;\n      this.users.push(userObject); // On emet le Subject qui fait appel à la couche d'abstraction des données\n\n      this.emitUserSubject();\n    } // ===============================================================\n    // Appels vers bdd firebase\n    // ==============================================================\n\n    /**\r\n     * Methode permettant d'enregistrer des users dans firebase\r\n     * On utilise la methode put() pour ecraser les données users à chaque clic sur le bouton. Si on utilise la methode post(), ca\r\n     * enregistrera en bdd à chaque clic l'ensemble des users à enregistrer.\r\n     * L'url du serveur doit etre complété avec ce qu'on veut enregistrer (ici, les users), suivi de .json. C'est la convention de\r\n     * firebase pour le format de fichier json. Les methodes post() et put() retournent un Observable, elle ne fait pas d'appel à elle toute\r\n     * seule.\r\n     * C'est en y souscrivant que l'appel est lancé.\r\n     * Dans la methode subscribe, on prevoit les cas ou ca fonctionne et ou ca fonctionne pas.\r\n     */\n\n\n    saveUsersToServer() {\n      this.httpClient.put('https://angularoc-dbb41.firebaseio.com/users.json', this.users).subscribe(() => {\n        console.log('enregistrement terminé dans firebase !');\n      }, error => {\n        console.log('erreur d\\'enregistrement dans firebase !');\n      });\n    }\n    /**\r\n     * Methode permettant de recuperer la liste des users depuis la bdd firebase\r\n     * Comme pour  post()  et  put() , la méthode get() retourne un Observable, mais puisqu'ici, vous allez recevoir des données, TypeScript\r\n     * a besoin de savoir de quel type elles seront (l'objet retourné est d'office considéré comme étant un Object).  Vous devez donc, dans\r\n     * ce cas précis, ajouter  <any[]>  pour dire que vous allez recevoir un array de type  any , et que donc TypeScript peut traiter cet\r\n     * objet comme un array : si vous ne le faites pas, TypeScript vous dira qu'un array ne peut pas être redéfini comme Object.\r\n     */\n\n\n    getAppareilsFromServer() {\n      this.httpClient.get('https://angularoc-dbb41.firebaseio.com/users.json').subscribe(response => {\n        this.users = response;\n        this.emitUserSubject();\n      }, error => {\n        console.log('Erreur ! : ' + error);\n      });\n    }\n\n  }\n\n  UserService.ɵfac = function UserService_Factory(t) {\n    return new (t || UserService)(i0.ɵɵinject(i1.HttpClient));\n  };\n\n  UserService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: UserService,\n    factory: UserService.ɵfac\n  });\n  return UserService;\n})();",
  "map": null,
  "metadata": {},
  "sourceType": "module"
}
